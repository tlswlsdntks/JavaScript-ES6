<html>

<head>
	<meta charset="UTF-8" />
	<title> 함수형 프로그래밍과 JavaScript ES6+ </title>
	<script src="lib/fx.js"></script>
</head>

<body>

	<script>

		// ## Array를 통해 알아보기.
		log("=== Arr ===");
		const arrL = [1, 2, 3];
		// for (const a of arr) log(a);
		let iter1 = arrL[Symbol.iterator]();
		iter1.next();
		iter1.next();
		for (const a of iter1) log(a);

		// ## Set를 통해 알아보기.
		log("=== Set ===");
		const setL = new Set([1, 2, 3]);
		// for (const a of setL) log(a);
		let iter2 = setL[Symbol.iterator]();
		iter2.next();
		iter2.next();
		for (const a of iter2) log(a);

		// ## Map를 통해 알아보기.
		log("=== Map ===");
		const mapL = new Map([['a', 1], ['b', 2], ['c', 3]]);
		// for (const a of mapL) log(a);
		let iter3 = mapL[Symbol.iterator]();
		iter3.next();
		iter3.next();
		for (const a of iter3) log(a);
		for (const a of mapL.keys()) log(a);
		for (const a of mapL.values()) log(a);
		for (const a of mapL.entries()) log(a);

		// ## 이터러블/이터레이터 프로토콜
		// 	- 이터러블: 이터레이터를 리턴하는 [Symbol.iterator]()를 가진 값.
		log(arrL[Symbol.iterator]);
		// arr[Symbol.iterator] = null;
		log(setL[Symbol.iterator]);
		log(mapL[Symbol.iterator]);

		//	- 이터레이터: { value, done } 객체를 리턴하는 next()를 가진 값.
		let iterator = arrL[Symbol.iterator]();
		for (const a of arrL) log(iterator.next());

		//	- 이터러블/이터레이터 프로토콜: 이러러블을 for...of, 전개 연산자 등과 함께 동작하도록한 규약.
		let it = mapL.values();
		let it2 = it[Symbol.iterator]();
		console.log(it2.next());
		console.log(it2.next());
		console.log(it2.next());

	</script>

	<script>

		// ### 사용자 정의 이터러블을 통해 알아보기.
		const iterable = {
			[Symbol.iterator]() {
				let i = 3;
				return {
					next() {
						return i == 0 ? { done: true } : { value: i--, done: false }
					},
					[Symbol.iterator]() { return this; }
				}
			}
		};
		let iterator2 = iterable[Symbol.iterator]();
		console.log(iterator2.next());
		console.log(iterator2.next());
		console.log(iterator2.next());
		console.log(iterator2.next());

		for (const a of iterable) log(a);
		for (const a of iterator2) log(a);

		const arr2 = [1, 2, 3];
		let iter22 = arr2[Symbol.iterator]();
		iter22.next();
		log(iter22[Symbol.iterator]() == iter22);
		for (const a of iter22) log(a);

		for (const a of document.querySelectorAll('*')) log(a);
		const all = document.querySelectorAll('*');
		let iter33 = all[Symbol.iterator]();
		log(iter33.next());
		log(iter33.next());
		log(iter33.next());

	</script>

	<script>

		// ## 전개연산자
		const aa = [1, 2];
		// aa[Symbol.iterator] = null;
		log(...aa);
		log([...aa, [3, 4]]);
		log([...aa, ...[3, 4]]);
		log([...aa, ...arrL, ...setL, ...mapL.keys()]);

	</script>

	<script>

		// # 제네레이터/이터레이터
		// 	- 제네레이터: 이터레이터이자 이터러블을 생성하는 함수.

		function* gen() {
			yield 1;
			if (false) yield 2;
			yield 3;
			return 100;
		}
		for (const a of gen()) log(a);
		let iter0 = gen();
		log(iter0 == iter0[Symbol.iterator]());
		log(iter0.next());
		log(iter0.next());
		log(iter0.next());

	</script>

	<script>

		// # odds
		function* infinity(i = 0) {
			while (true) yield i++;
		}

		function* limit(l, iter) {
			for (const a of iter) {
				yield a;
				if (a == l) return;
			}
		}

		function* odds(l) {
			for (const a of limit(l, infinity(1))) {
				if (a % 2) yield a;
			}
		}

		let iterodds = odds(10);
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());

		for (const a of odds(40)) log(a);

	</script>

	<script>

		// # for of, 전개 연산자, 구조 분해, 나머지 연산자
		log(...odds(10));
		log([...odds(10), ...odds(20)]);

		const [head, ...tail] = odds(5);
		log(head);
		log(tail);

		const [one, two, ...rest] = odds(10);
		log(one);
		log(two);
		log(rest);

	</script>

	<script>

		const products = [
			{ name: '반팔티', price: 15000 },
			{ name: '긴팔티', price: 20000 },
			{ name: '핸드폰케이스', price: 15000 },
			{ name: '후드티', price: 30000 },
			{ name: '바지', price: 25000 },
		];

	</script>

	<script>

		// # map
		let names = [];
		for (const p of products) {
			names.push(p.name);
		}
		log(names);
		log(map(p => p.name, products));

		// # 이터러블 프로토콜을 이용한 map의 다형성
		log([1, 2, 3].map(a => a + 1));

		// log(document.querySelectorAll('*').map(el => el.nodeName));
		log(map(el => el.nodeName, document.querySelectorAll('*')));

		let iter = document.querySelectorAll('*')[Symbol.iterator]();
		log(iter.next());
		log(iter.next());
		log(iter.next());
		log(iter.next());

		function* gen() {
			yield 1;
			if (false) yield 2;
			yield 3;
		}
		log(map(a => a * a, gen()));

		let m = new Map();
		m.set('a', 10);
		m.set('b', 20);
		// log(map(([key, value]) => [key, value * 2], m));
		log(new Map(map(([key, value]) => [key, value * 2], m)));

	</script>

	<script>

		// # filter
		let over20000 = [];
		for (const p of products) {
			if (p.price >= 20000) over20000.push(p);
		}
		// log(over20000);
		log(...over20000);
		// log(filter(p => p.price >= 20000, products));
		log(...filter(p => p.price >= 20000, products));

		log(filter(n => n % 2, [1, 2, 3, 4]));
		log(filter(n => n % 2, function* () {
			yield 1;
			yield 2;
			yield 3;
			yield 4;
			yield 5;
		}()));

	</script>

	<script>

		// # reduce
		let nums = [1, 2, 3, 4, 5];
		let total = 0;
		for (const n of nums) total += n;
		log(total);
		let add = (a, b) => a + b;
		log(reduce(add, 0, nums));
		// log(add(add(add(add(add(0, 1), 2), 3), 4), 5));
		log(reduce(add, nums));

		log(reduce((tp, product) => tp += product.price, 0, products));

	</script>

	<script>

		// # 중첩사용과 함수형사고
		log(reduce(add, map(p => p.price, filter(p => p.price < 20000, products))));
		log(reduce(add, filter(n => n >= 20000, map(p => p.price, products))));

	</script>

	<script>

		// # 코드를 값으로 다루어 표현력 높이기
		// # go
		go(
			0,
			a => a + 1,
			a => a + 10,
			a => a + 100,
			log
		)

		// # pipe
		let p1 = pipe(
			(a, b) => a + b,
			a => a + 10,
			a => a + 100
		)
		log(p1(0, 1));

		go(
			products,
			products => filter(p => p.price < 20000, products),
			products => map(p => p.price, products),
			prices => reduce(add, prices),
			log
		)

		// # curry
		let mult = curry((a, b) => a * b);
		log(mult(3)(5));
		let mult3 = mult(3);
		log(mult3(10));
		log(mult3(5));
		log(mult3(3));

		go(
			products,
			filter(p => p.price < 20000),
			map(p => p.price),
			reduce(add),
			log
		)

		// # 함수 조합으로 함수 만들기
		const total_price = pipe(
			map(p => p.price),
			reduce(add)
		)

		const base_total_price = predi => pipe(
			filter(predi),
			total_price
		)

		go(
			products,
			base_total_price((p => p.price < 20000)),
			log
		)

	</script>

	<script>

		// # range
		const range = l => {
			let i = -1;
			let res = [];
			while (++i < l) {
				// log(i, 'range');
				res.push(i);
			}
			return res;
		}
		let listR = range(4);
		log(listR);
		log(reduce(add, listR));

		// # 느긋한 L.range
		const L = {};
		L.range = function* (l) {
			let i = -1;
			while (++i < l) {
				// log(i, 'L.range');
				yield i;
			}
		}
		let listL = L.range(4);
		log(listL);
		log(listL.next());
		log(listL.next());
		log(listL.next());
		log(listL.next());
		log(reduce(add, listL));

		function test(name, time, f) {
			console.time(name);
			while (time--) f();
			console.timeEnd(name);
		}
		test('range', 10, (_) => reduce(add, range(1000000)));
		test('L.range', 10, (_) => reduce(add, L.range(1000000)));

	</script>

	<script>

		// # take
		const take = curry((l, iter) => {
			let res = [];
			for (const a of iter) {
				res.push(a);
				if (res.length == l) return res;
			}
			return res;
		});

		console.time('');
		go(
			range(1000000),
			take(5),
			reduce(add),
			log
		)
		console.timeEnd('');

		console.time('');
		go(
			L.range(1000000),
			// L.range(Infinity),
			take(5),
			reduce(add),
			log
		)
		console.timeEnd('');

	</script>

	<script>

		// # 이터러블 중심 프로그래밍의 지연 평가(Lazy Evaluation)
		// 	- 제때 계산법
		// 	- 느긋한 계산법
		// 	- 제네레이터/이터레이터 프로토콜을 기반으로 구현

		// # L.map
		L.map = function* (fn, iter) {
			for (const a of iter) yield fn(a);
		}
		let itt = L.map(a => a + 10, [1, 2, 3, 4]);
		// log(itt.next());
		// log(itt.next());
		// log(itt.next());
		// log(...itt);
		log(itt.next().value);

		// # L.filter
		L.map = function* (fn, iter) {
			for (const a of iter) if (fn(a)) yield a;
		}
		let itt2 = L.map(a => a % 2, [1, 2, 3, 4, 5]);
		// log(itt2.next());
		// log(itt2.next());
		// log(itt2.next());
		// log(...itt2);
		log(itt2.next().value);

	</script>

	<script>

		// # range, map, filter, take, reduce 과 
		// L.range, L.map, L.filter, take, reduce의 평가순서

		// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, ... ]
		// [ 10, 11, 12, ... ]
		// [ 11, 13, 15, ... ]
		// [ 11, 13 ]
		console.time('');
		go(
			range(10),
			map(a => a + 10),
			filter(a => a % 2),
			take(2),
			log
		)
		console.timeEnd('');

		// 0	  1
		// 10	  11
		// false  true
		console.time('');
		go(
			L.range(Infinity),
			L.map(n => n + 10),
			L.filter(a => a % 2),
			take(2),
			log
		)
		console.timeEnd('');

		// ### map, filter 계열 함수들이 가지는 결합 법칙
		//	- 사용하는 데이터가 무엇이든 지
		//	- 사용하는 보조 함수가 순수 함수라면 무엇이든 지
		//	- 아래와 같이 결합한다면 둘 다 결과 같다.
		// [[mapping, mapping], [filtering, filtering], [mapping, mapping]]
		// =
		// [[mapping, filtering, mapping], [mapping, filtering, mapping]]

	</script>

	<script>

		// queryStr
		let queryStr = pipe(
			Object.entries,
			map(([key, value]) => `${key}=${value}`),
			reduce((a, b) => `${a}&${b}`)
		)
		// log(queryStr({ limit: 10, offset: 10, type: 'notice' }));

		L.entries = function* (obj) {
			for (const a in obj) yield [a, obj[a]];
		}

		// join
		const join = curry((sep = ',', iter) => reduce((a, b) => `${a}${sep}${b}`, iter));
		queryStr = pipe(
			L.entries,
			map(([key, value]) => `${key}=${value}`),
			join('&')
		)
		log(queryStr({ limit: 10, offset: 10, type: 'notice' }));

		function* ab() {
			yield 10;
			yield 11;
			yield 12;
			yield 13;
		}
		log(join('-', ab()));
		// log(ab.join('-'));

	</script>

	<script>

		let users = [
			{ age: 32 },
			{ age: 31 },
			{ age: 37 },
			{ age: 28 },
			{ age: 25 },
			{ age: 32 },
			{ age: 31 },
			{ age: 37 }
		];

		// # find
		const find = curry((f, iter) => go(
			iter,
			L.filter(a => (console.log(a), f(a))),
			a => (console.log(a), a),
			// L.filter(f),
			take(1),
			([a]) => a
		));

		log(find(u => u.age < 30)(users));

		go(
			users,
			map(u => u.age),
			find(a => a < 30),
			log
		)

	</script>

	<script>

		// # L.map + take 로 map 만들기	
		let takeAll = take(Infinity);
		map = curry((fn, iter) => go(iter, L.map(fn), takeAll));
		// map = curry(pipe(L.map, takeAll));
		log(map(a => a + 10, L.range(10)));

		// # L.filter + take 로 filter 만들기
		filter = curry(pipe(L.filter, takeAll));
		log(filter(a => a % 2, L.range(10)));

	</script>

	<script>

		// # flatten
		const isIterable = a => a && a[Symbol.iterator];
		L.flatten = function* (iter) {
			for (const a of iter) {
				// if (isIterable(a)) for (const b of a) yield b;
				if (isIterable(a)) yield* a;
				else yield a;
			}
		}
		let it3 = L.flatten([...[1, 2], 3, 4, ...[5, 6], ...[7, 8, 9]]);
		// log(...it3);
		log(it3.next());
		log(it3.next());
		log(it3.next());
		log(it3.next());
		log(take(3, L.flatten([...[1, 2], 3, 4, ...[5, 6], ...[7, 8, 9]])));

		const flatten = pipe(L.flatten, takeAll);
		log(flatten([...[1, 2], 3, 4, ...[5, 6], ...[7, 8, 9]]));

		// # L.deepFlat
		L.deepFlat = function* f(iter) {
			for (const a of iter) {
				if (isIterable(a)) yield* f(a);
				else yield a;
			}
		};
		log([...L.deepFlat([1, [2, [3, 4], [[5]]]])]);

	</script>

	<script>

		// # L.flatMap
		log([[1, 2], [3, 4], [5, 6, 7]].flatMap(a => a.map(a => a * a)));
		log(flatten([[1, 2], [3, 4], [5, 6, 7]].map(a => a.map(a => a * a))));

		L.flatMap = curry(pipe(L.map, L.flatten));
		const flatMap = curry(pipe(L.map, flatten));

		// let flit = L.flatMap(map(a => a * a), [[1, 2], [3, 4], [5, 6, 7]]);
		// log(...flit);

		let flit = L.flatMap(a => a, [[1, 2], [3, 4], [5, 6, 7]]);
		// log([...flit]);
		log(flit.next());
		log(flit.next());
		log(flit.next());
		log(flit.next());
		log(flit.next());
		log(flit.next());
		log(flit.next());
		log(flit.next());

		let fmit = L.flatMap(L.range, L.map(a => a + 1, [1, 2, 3]));
		log(fmit.next());
		log(fmit.next());
		log(fmit.next());
		log(fmit.next());

		// [0, 1, 0, 1, 2, 0, 1, 2, 3]
		log(flatMap(range, map(a => a + 1, [1, 2, 3])));
		// [0, 1, 0]
		log(take(3, flatMap(range, map(a => a + 1, [1, 2, 3]))));

	</script>

	<script>

		// # 2차원 배열 다루기
		let arr2d = [
			[1, 2],
			[3, 4, 5],
			[6, 7, 8],
			[9, 10]
		];

		go(
			arr2d,
			L.flatten,
			L.filter(a => a % 2),
			L.map(a => a * a),
			take(3),
			log
		)

	</script>

	<script>

		// # 지연성 / 이터러블 중심 프로그래밍 실무적인 코드
		users = [
			{
				name: 'a', age: 21, family: [
					{ name: 'a1', age: 53 }, { name: 'a2', age: 47 },
					{ name: 'a3', age: 16 }, { name: 'a4', age: 15 }
				]
			},
			{
				name: 'b', age: 24, family: [
					{ name: 'b1', age: 58 }, { name: 'b2', age: 51 },
					{ name: 'b3', age: 19 }, { name: 'b4', age: 22 }
				]
			},
			{
				name: 'c', age: 31, family: [
					{ name: 'c1', age: 64 }, { name: 'c2', age: 62 },
				]
			},
			{
				name: 'd', age: 20, family: [
					{ name: 'd1', age: 42 }, { name: 'd2', age: 42 },
					{ name: 'd3', age: 11 }, { name: 'd4', age: 7 }
				]
			},
		]

		go(
			users,
			L.flatMap(u => u.family),
			L.filter(u => u.age < 20),
			L.map(u => u.age),
			take(3),
			reduce(add),
			log
		)

	</script>

</body>

</html>