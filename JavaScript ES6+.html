<html>

<head>
	<meta charset="UTF-8" />
	<title> 함수형 프로그래밍과 JavaScript ES6+ </title>
	<script> const log = console.log; </script>
</head>

<body>

	<script>

		// # 평가
		// 	- 코드가 계산(Evaluation) 되어 값을 만드는 것.
		// 	- 1
		// 	- 1 + 2
		// 	- (1 + 2) + 4
		// 	- 3 + 4
		// 	- [1, 2]
		// 	- [1, 5]
		// 	- [1, 2 + 3]
		// 	- [1, 2, [3, 4]]
		// 	- [1, 2, ..[3, 4]]

		// # 일급
		// 	- 값으로 다룰 수 있다.
		// 	- 변수에 담을 수 있다.
		// 	- 함수의 인자로 사용될 수 있다.
		// 	- 함수의 결과로 사용될 수 있다.

		const a = 10;
		const add10 = a => a + 10;
		const r = add10(a);
		log(r);

	</script>

	<script>

		// # 일급함수
		// 	- 함수를 값으로 다룰 수 있다.
		//	- 조합성과 추상화의 도구.
		const add5 = a => a + 5;
		log(add5);
		log(add5(5));

		const f1 = (_) => (_) => 1;
		log(f1());

		const f2 = f1();
		log(f2);
		log(f2());

	</script>

	<script>

		// # 고차함수
		//	- 함수를 값으로 다루는 함수

		// ## 함수를 인자로 받아서 실행하는 함수
		// 	- apply1
		// 	- times
		//	- addMaker

		const apply1 = f => f(1);
		const add2 = a => a + 2;
		log(apply1(add2));
		log(apply1(a => a + 2));

		const times = (f, n) => {
			let i = -1;
			while (++i < n) f(i);
		}
		times(log, 3);
		times(a => log(a + 10), 3);

		const addMaker = a => b => a + b;
		const add15 = addMaker(15);
		log(add15);
		log(add15(5));

	</script>

	<script>

		// ## 기존과 달라진 ES6에서의 리스트 순회
		//	- for i++
		//	- for of
		const list = [1, 2, 3];
		const str = "abc";
		for (var i = 0, len = list.length; i < len; i++) log(list[i]);
		for (var i = 0, len = str.length; i < len; i++) log(str[i]);

		for (const a of list) log(a);
		for (const a of str) log(a);

	</script>

	<script>

		// ## Array를 통해 알아보기.
		log("=== Arr ===");
		const arrL = [1, 2, 3];
		// for (const a of arr) log(a);
		let iter1 = arrL[Symbol.iterator]();
		iter1.next();
		iter1.next();
		for (const a of iter1) log(a);

		// ## Set를 통해 알아보기.
		log("=== Set ===");
		const setL = new Set([1, 2, 3]);
		// for (const a of setL) log(a);
		let iter2 = setL[Symbol.iterator]();
		iter2.next();
		iter2.next();
		for (const a of iter2) log(a);

		// ## Map를 통해 알아보기.
		log("=== Map ===");
		const mapL = new Map([['a', 1], ['b', 2], ['c', 3]]);
		// for (const a of mapL) log(a);
		let iter3 = mapL[Symbol.iterator]();
		iter3.next();
		iter3.next();
		for (const a of iter3) log(a);
		for (const a of mapL.keys()) log(a);
		for (const a of mapL.values()) log(a);
		for (const a of mapL.entries()) log(a);

		// ## 이터러블/이터레이터 프로토콜
		// 	- 이터러블: 이터레이터를 리턴하는 [Symbol.iterator]()를 가진 값.
		log(arrL[Symbol.iterator]);
		// arr[Symbol.iterator] = null;
		log(setL[Symbol.iterator]);
		log(mapL[Symbol.iterator]);

		//	- 이터레이터: { value, done } 객체를 리턴하는 next()를 가진 값.
		let iterator = arrL[Symbol.iterator]();
		for (const a of arrL) log(iterator.next());

		//	- 이터러블/이터레이터 프로토콜: 이러러블을 for...of, 전개 연산자 등과 함께 동작하도록한 규약.
		let it = mapL.values();
		let it2 = it[Symbol.iterator]();
		console.log(it2.next());
		console.log(it2.next());
		console.log(it2.next());

	</script>

	<script>

		// ### 사용자 정의 이터러블을 통해 알아보기.
		const iterable = {
			[Symbol.iterator]() {
				let i = 3;
				return {
					next() {
						return i == 0 ? { done: true } : { value: i--, done: false }
					},
					[Symbol.iterator]() { return this; }
				}
			}
		};
		let iterator2 = iterable[Symbol.iterator]();
		console.log(iterator2.next());
		console.log(iterator2.next());
		console.log(iterator2.next());
		console.log(iterator2.next());

		for (const a of iterable) log(a);
		for (const a of iterator2) log(a);

		const arr2 = [1, 2, 3];
		let iter22 = arr2[Symbol.iterator]();
		iter22.next();
		log(iter22[Symbol.iterator]() == iter22);
		for (const a of iter22) log(a);

		for (const a of document.querySelectorAll('*')) log(a);
		const all = document.querySelectorAll('*');
		let iter33 = all[Symbol.iterator]();
		log(iter33.next());
		log(iter33.next());
		log(iter33.next());

	</script>

	<script>

		// ## 전개연산자
		const aa = [1, 2];
		// aa[Symbol.iterator] = null;
		log(...aa);
		log([...aa, [3, 4]]);
		log([...aa, ...[3, 4]]);
		log([...aa, ...arrL, ...setL, ...mapL.keys()]);

	</script>

	<script>

		// # 제네레이터/이터레이터
		// 	- 제네레이터: 이터레이터이자 이터러블을 생성하는 함수.

		function* gen() {
			yield 1;
			if (false) yield 2;
			yield 3;
			return 100;
		}
		for (const a of gen()) log(a);
		let iter0 = gen();
		log(iter0 == iter0[Symbol.iterator]());
		log(iter0.next());
		log(iter0.next());
		log(iter0.next());

	</script>

	<script>

		// # odds
		function* infinity(i = 0) {
			while (true) yield i++;
		}

		function* limit(l, iter) {
			for (const a of iter) {
				yield a;
				if (a == l) return;
			}
		}

		function* odds(l) {
			for (const a of limit(l, infinity(1))) {
				if (a % 2) yield a;
			}
		}

		let iterodds = odds(10);
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());

		for (const a of odds(40)) log(a);

	</script>

	<script>

		// # for of, 전개 연산자, 구조 분해, 나머지 연산자
		log(...odds(10));
		log([...odds(10), ...odds(20)]);

		const [head, ...tail] = odds(5);
		log(head);
		log(tail);

		const [one, two, ...rest] = odds(10);
		log(one);
		log(two);
		log(rest);

	</script>

	<script>

		const products = [
			{ name: '반팔티', price: 15000 },
			{ name: '긴팔티', price: 20000 },
			{ name: '핸드폰케이스', price: 15000 },
			{ name: '후드티', price: 30000 },
			{ name: '바지', price: 25000 },
		];

		let names = [];
		for (const p of products) {
			names.push(p.name);
		}
		log(names);

		// # map
		const map = (fn, iter) => {
			let res = [];
			for (const a of iter) {
				res.push(fn(a));
			}
			return res;
		}
		log(map(p => p.name, products));

		// # 이터러블 프로토콜을 이용한 map의 다형성
		log([1, 2, 3].map(a => a + 1));
		// log(document.querySelectorAll('*').map(el => el.nodeName));
		log(map(el => el.nodeName, document.querySelectorAll('*')));
		let iter = document.querySelectorAll('*')[Symbol.iterator]();
		log(iter.next());
		log(iter.next());
		log(iter.next());
		log(iter.next());

		function* gen() {
			yield 1;
			if (false) yield 2;
			yield 3;
		}
		log(map(a => a * a, gen()));

		let m = new Map();
		m.set('a', 10);
		m.set('b', 20);
		// log(map(([key, value]) => [key, value * 2], m));
		log(new Map(map(([key, value]) => [key, value * 2], m)));

	</script>

	<script>

		// # filter
		let over20000 = [];
		for (const p of products) {
			if (p.price >= 20000) over20000.push(p);
		}
		// log(over20000);
		log(...over20000);

		const filter = (fn, iter) => {
			let res = [];
			for (const a of iter) if (fn(a)) res.push(a);
			return res;
		}
		// log(filter(p => p.price >= 20000, products));
		log(...filter(p => p.price >= 20000, products));

		log(filter(n => n % 2, [1, 2, 3, 4]));
		log(filter(n => n % 2, function* () {
			yield 1;
			yield 2;
			yield 3;
			yield 4;
			yield 5;
		}()));

	</script>

</body>

</html>