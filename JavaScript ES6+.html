<html>

<head>
	<meta charset="UTF-8" />
	<title> 함수형 프로그래밍과 JavaScript ES6+ </title>
	<script> const log = console.log; </script>
</head>

<body>

	<script>

		// # 평가
		// 	- 코드가 계산(Evaluation) 되어 값을 만드는 것.
		// 	- 1
		// 	- 1 + 2
		// 	- (1 + 2) + 4
		// 	- 3 + 4
		// 	- [1, 2]
		// 	- [1, 5]
		// 	- [1, 2 + 3]
		// 	- [1, 2, [3, 4]]
		// 	- [1, 2, ..[3, 4]]

		// # 일급
		// 	- 값으로 다룰 수 있다.
		// 	- 변수에 담을 수 있다.
		// 	- 함수의 인자로 사용될 수 있다.
		// 	- 함수의 결과로 사용될 수 있다.

		const a = 10;
		const add10 = a => a + 10;
		const r = add10(a);
		log(r);

	</script>

	<script>

		// # 일급함수
		// 	- 함수를 값으로 다룰 수 있다.
		//	- 조합성과 추상화의 도구.
		const add5 = a => a + 5;
		log(add5);
		log(add5(5));

		const f1 = (_) => (_) => 1;
		log(f1());

		const f2 = f1();
		log(f2);
		log(f2());

	</script>

	<script>

		// # 고차함수
		//	- 함수를 값으로 다루는 함수

		// ## 함수를 인자로 받아서 실행하는 함수
		// 	- apply1
		// 	- times
		//	- addMaker

		const apply1 = f => f(1);
		const add2 = a => a + 2;
		log(apply1(add2));
		log(apply1(a => a + 2));

		const times = (f, n) => {
			let i = -1;
			while (++i < n) f(i);
		}
		times(log, 3);
		times(a => log(a + 10), 3);

		const addMaker = a => b => a + b;
		const add15 = addMaker(15);
		log(add15);
		log(add15(5));

	</script>

	<script>

		// ## 기존과 달라진 ES6에서의 리스트 순회
		//	- for i++
		//	- for of
		const list = [1, 2, 3];
		const str = "abc";
		for (var i = 0, len = list.length; i < len; i++) log(list[i]);
		for (var i = 0, len = str.length; i < len; i++) log(str[i]);

		for (const a of list) log(a);
		for (const a of str) log(a);

	</script>

	<script>

		// ## Array를 통해 알아보기.
		log("=== Arr ===");
		const arr = [1, 2, 3];
		// for (const a of arr) log(a);
		let iter1 = arr[Symbol.iterator]();
		iter1.next();
		iter1.next();
		for (const a of iter1) log(a);

		// ## Set를 통해 알아보기.
		log("=== Set ===");
		const set = new Set([1, 2, 3]);
		// for (const a of set) log(a);
		let iter2 = set[Symbol.iterator]();
		iter2.next();
		iter2.next();
		for (const a of iter2) log(a);

		// ## Map를 통해 알아보기.
		log("=== Map ===");
		const map = new Map([['a', 1], ['b', 2], ['c', 3]]);
		// for (const a of iter2) log(a);
		let iter3 = map[Symbol.iterator]();
		iter3.next();
		iter3.next();
		for (const a of iter3) log(a);
		for (const a of map.keys()) log(a);
		for (const a of map.values()) log(a);
		for (const a of map.entries()) log(a);

		// ## 이터러블/이터레이터 프로토콜
		// 	- 이터러블: 이터레이터를 리턴하는 [Symbol.iterator]()를 가진 값.
		log(arr[Symbol.iterator]);
		// arr[Symbol.iterator] = null;
		log(set[Symbol.iterator]);
		log(map[Symbol.iterator]);

		//	- 이터레이터: { value, done } 객체를 리턴하는 next()를 가진 값.
		let iterator = arr[Symbol.iterator]();
		for (const a of arr) log(iterator.next());

		//	- 이터러블/이터레이터 프로토콜: 이러러블을 for...of, 전개 연산자 등과 함께 동작하도록한 규약.
		let it = map.values();
		let it2 = it[Symbol.iterator]();
		console.log(it2.next());
		console.log(it2.next());
		console.log(it2.next());

	</script>

	<script>

		// ### 사용자 정의 이터러블을 통해 알아보기.
		const iterable = {
			[Symbol.iterator]() {
				let i = 3;
				return {
					next() {
						return i == 0 ? { done: true } : { value: i--, done: false }
					},
					[Symbol.iterator]() { return this; }
				}
			}
		};
		let iterator2 = iterable[Symbol.iterator]();
		console.log(iterator2.next());
		console.log(iterator2.next());
		console.log(iterator2.next());
		console.log(iterator2.next());

		for (const a of iterable) log(a);
		for (const a of iterator2) log(a);

		const arr2 = [1, 2, 3];
		let iter22 = arr2[Symbol.iterator]();
		iter22.next();
		log(iter22[Symbol.iterator]() == iter22);
		for (const a of iter22) log(a);

		for (const a of document.querySelectorAll('*')) log(a);
		const all = document.querySelectorAll('*');
		let iter33 = all[Symbol.iterator]();
		log(iter33.next());
		log(iter33.next());
		log(iter33.next());

	</script>

	<script>

		// ## 전개연산자
		const aa = [1, 2];
		// aa[Symbol.iterator] = null;
		log(...aa);
		log([...aa, [3, 4]]);
		log([...aa, ...[3, 4]]);
		log([...aa, ...arr, ...set, ...map.keys()]);

	</script>

	<script>

		// # 제네레이터/이터레이터
		// 	- 제네레이터: 이터레이터이자 이터러블을 생성하는 함수.

		function* gen() {
			yield 1;
			if (false) yield 2;
			yield 3;
			return 100;
		}
		for (const a of gen()) log(a);
		let iter = gen();
		log(iter == iter[Symbol.iterator]());
		log(iter.next());
		log(iter.next());
		log(iter.next());

	</script>

	<script>

		// # odds
		function* infinity(i = 0) {
			while (true) yield i++;
		}

		function* limit(l, iter) {
			for (const a of iter) {
				yield a;
				if (a == l) return;
			}
		}

		function* odds(l) {
			for (const a of limit(l, infinity(1))) {
				if (a % 2) yield a;
			}
		}

		let iterodds = odds(10);
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());
		log(iterodds.next());

		for (const a of odds(40)) log(a);

	</script>

	<script>

		// # for of, 전개 연산자, 구조 분해, 나머지 연산자
		log(...odds(10));
		log([...odds(10), ...odds(20)]);

		const [head, ...tail] = odds(5);
		log(head);
		log(tail);

		const [one, two, ...rest] = odds(10);
		log(one);
		log(two);
		log(rest);

	</script>


</body>

</html>